import { createCanvas, loadImage, GlobalFonts } from '@napi-rs/canvas';
import { Database } from 'st.db';
import { Database as ReplitDB } from "quick.replit";
import { join, resolve } from 'node:path';
import { buffer } from 'node:stream/consumers';
import fs from "node:fs";
import inquirer from "inquirer";
import startBot from "../events/bot.js";
import { Interval } from 'quickinterval';
import { createRouletteGifImage, shuffleArray, getRandomDarkHexCode, createRouletteImage, getRandomNumber } from "roulette-image";
import { GifEncoder } from '@skyra/gifenc';
import { InteractionCollector } from 'eris-collects';
const is_replit = process.env.REPL_ID && process.env.REPL_SLUG && process.env.REPL_OWNER;
const shuruhatik = `█▀ █░█ █░█ █▀█ █░█ █░█ ▄▀█ ▀█▀ █ █▄▀\n▄█ █▀█ █▄█ █▀▄ █▄█ █▀█ █▀█ ░█░ █ █░█`
const config = is_replit ? new ReplitDB() : new Database("./config.yml");
const settings = is_replit ? new Database("./config.yml") : config;

GlobalFonts.registerFromPath(join(resolve(), '..', 'fonts', 'Tajawal.ttf'), 'Tajawal');
GlobalFonts.registerFromPath(join(resolve(), '..', 'fonts', 'Arial.ttf'), 'Arial');
GlobalFonts.registerFromPath(join(resolve(), '..', 'fonts', 'DejaVuSans.ttf'), 'DejaVuSans');
GlobalFonts.registerFromPath(join(resolve(), '..', 'fonts', 'Symbola_hint.ttf'), 'Symbola_hint');
GlobalFonts.registerFromPath(join(resolve(), '..', 'fonts', 'Symbola.ttf'), 'Symbola');


async function createRouletteGifImage(sectors, return_stream = false) {
  let main = sectors;
  let gif_image = await createGifImage(120);
  let one_image = await createRouletteImage(main, false, false);
  let frames = await getRotateRouletteImage(one_image, "https://i.imgur.com/OpsUf7T.png");
  let one_ctx = await createRouletteImage(main, true)

  let roulette_images = [...frames, one_ctx];


  for (let image_ctx of roulette_images) {
    let delay = roulette_images.indexOf(image_ctx) >= 29 ? 150 : roulette_images.indexOf(image_ctx) >= 26 ? 120 :
      roulette_images.indexOf(image_ctx) >= 21 ? 100 : 75

    await gif_image.encoder.setDelay(25)
    await gif_image.encoder.addFrame(image_ctx);
  }

  if (roulette_images.length > 0) {
    await gif_image.encoder.finish();
    return return_stream ? gif_image.stream : await buffer(gif_image.stream);
  }
}



async function createGifImage(delay = 120) {
  const encoder = new GifEncoder(500, 500);
  const stream = encoder.createReadStream();
  encoder.start();
  encoder.setRepeat(-1);
  encoder.setQuality(1);
  encoder.setTransparent(true)
  return { encoder, loadImage, stream }
}


async function getRotateRouletteImage(image_buffer, specific_win_avatar) {
  return new Promise(async (resolve, reject) => {
    const img = await loadImage(image_buffer);
    const avatar = await loadImage(specific_win_avatar);
    const canvasWidth = 500;
    const canvasHeight = 500;
    const centerX = canvasWidth / 2;
    const centerY = canvasHeight / 2;
    const angleIncrement = (2 * Math.PI) / 30;
    const frames = [];

    for (let i = 0; i < 30; i++) {
      const canvas = createCanvas(canvasWidth, canvasHeight);
      const ctx = canvas.getContext('2d');
      ctx.save();

      ctx.clearRect(0, 0, canvasWidth, canvasHeight);

      const angle = angleIncrement * i;

      ctx.translate(centerX, centerY);
      ctx.rotate(angle);
      ctx.drawImage(img, -img.width / 2, -img.height / 2);
      ctx.restore();

      ctx.beginPath();
      ctx.moveTo(499, 203);
      ctx.lineTo(468, 230);
      ctx.lineTo(499, 257);
      ctx.fillStyle = '#e2e2e2';
      ctx.fill();
      ctx.closePath();

      const circle = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        radius: 75,
      }
      ctx.beginPath();
      ctx.strokeStyle = "white";
      ctx.arc(circle.x, circle.y, circle.radius + 2, 0, Math.PI * 2, true);
      ctx.fillStyle = 'white';
      ctx.fill();
      ctx.closePath()
      ctx.beginPath();
      ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2, true);
      ctx.closePath();
      ctx.clip();
      const aspect = avatar.height / avatar.width;
      const hsx = circle.radius * Math.max(1.0 / aspect, 1.0);
      const hsy = circle.radius * Math.max(aspect, 1.0);
      ctx.drawImage(avatar, circle.x - hsx, circle.y - hsy, hsx * 2, hsy * 2);

      frames.push(ctx);
    }
    resolve(frames)
  })
}

async function createRouletteImage(sectors, return_ctx = false, pointer = true, specific_win_avatar) {
  return new Promise(async (resolve, reject) => {
    const canvas = createCanvas(500, 500);
    const ctx = canvas.getContext('2d');
    const sectorAngle = (2 * Math.PI) / sectors.length;
    sectors.forEach(async (sector, i) => {
      const startAngle = sectorAngle * i;
      const endAngle = startAngle + sectorAngle;
      ctx.beginPath();
      ctx.moveTo(250, 250);
      ctx.arc(250, 250, 244, startAngle, endAngle);
      ctx.closePath();
      ctx.fillStyle = sector.color;
      ctx.fill();
      ctx.save();
      ctx.translate(250, 250);
      ctx.rotate(startAngle + sectorAngle / 2);
      let text = `${sector.number + 1}- ${sector.username}`.trim();
      ctx.textAlign = "left";
      ctx.fillStyle = "#fff";
      ctx.font = "bold " + Math.round(26 - sectors.length * 0.442) + "px Tajawal,Symbola,Symbola_hint,DejaVuSans,Arial";
      ctx.fillText(text.length > 14 ? text.slice(0) + ".." : text.slice(0, 16), 87, 4);
      ctx.restore();
      const angle = i * sectorAngle;
      const x = Math.cos(angle) * 244 + 250;
      const y = Math.sin(angle) * 244 + 250;
      ctx.beginPath();
      ctx.moveTo(250, 250);
      ctx.lineTo(x, y);
      ctx.lineWidth = 3;
      ctx.strokeStyle = "#fff";
      ctx.stroke();
    });
    ctx.beginPath();
    ctx.arc(250, 250, 244, 0, 2 * Math.PI);
    ctx.lineWidth = 2
    ctx.strokeStyle = "#fff";
    ctx.stroke();
    if (pointer) {
      ctx.beginPath();
      ctx.moveTo(499, 203);
      ctx.lineTo(468, 230);
      ctx.lineTo(499, 257);
      ctx.fillStyle = '#e2e2e2';
      ctx.fill();
      ctx.closePath();

      const avatar = await loadImage(specific_win_avatar ? specific_win_avatar : sectors[sectors.length - 1].avatarURL);
      const circle = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        radius: 75,
      }
      ctx.beginPath();
      ctx.strokeStyle = "white";
      ctx.arc(circle.x, circle.y, circle.radius + 2, 0, Math.PI * 2, true);
      ctx.fillStyle = 'white';
      ctx.fill();
      ctx.closePath()
      ctx.beginPath();
      ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2, true);
      ctx.closePath();
      ctx.clip();
      const aspect = avatar.height / avatar.width;
      const hsx = circle.radius * Math.max(1.0 / aspect, 1.0);
      const hsy = circle.radius * Math.max(aspect, 1.0);
      ctx.drawImage(avatar, circle.x - hsx, circle.y - hsy, hsx * 2, hsy * 2);

    }
    resolve(return_ctx ? ctx : await canvas.toBuffer('image/png'));
  })
}


function disabledMultipleButtons(mm, specific_custom_id, username, is_leave = false) {
  mm.components.forEach(async (a, i) => {
    a.components.forEach(async (b, e) => {
      if (specific_custom_id && mm.components[i].components[e].custom_id.includes(specific_custom_id)) {
        mm.components[i].components[e].disabled = is_leave ? false : true
        if (username) mm.components[i].components[e].label = is_leave ? `${+mm.components[i].components[e].custom_id.split("_")[1] + 1}` : username;
      } else if (!specific_custom_id) {
        mm.components[i].components[e].disabled = true
      }
      if (e + 1 == a.components.length && mm.components.length == i + 1) {
        return mm.components
      }
    })
  })
}

function getMultipleButtons(all_buttons) {
  let components = [];
  for (let i = 0; i < all_buttons.length; i += 5) {
    let component = { components: [], type: 1 }
    for (let btn of all_buttons.slice(i, i + 5)) {
      component.components.push(btn);
    }
    components.push(component);
  }
  return components;
}
function getRandomNumber(length, excludedNumbers = []) {
  var number = 0;
  do {
    number = Math.floor(Math.random() * length) + 1;
  } while (excludedNumbers.includes(number));
  return number;
}
function getRandomGifColor() {
  const r = Math.floor(Math.random() * 256);
  const g = Math.floor(Math.random() * 256);
  const b = Math.floor(Math.random() * 256);

  const hex = ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
  return '#' + hex;
}

function getRandomDarkHexCode() {
  let letters = '0123456789ABCDEF';
  let color = '#';
  let lightness = Math.floor(Math.random() * 25);
  for (var i = 0; i < 6; i++) {
    color += letters[Math.floor(Math.random() * 16)];
  }

  let darkColor = color;

  while (getBrightness(darkColor) >= 128 || darkColor === '#000000') {
    color = '#';
    for (let i = 0; i < 6; i++) {
      color += letters[Math.floor(Math.random() * 16)];
    }
    darkColor = color;
  }

  return darkColor;
}

function getBrightness(color) {
  const hex = color.replace('#', '');
  const r = parseInt(hex.substring(0, 2), 16);
  const g = parseInt(hex.substring(2, 4), 16);
  const b = parseInt(hex.substring(4, 6), 16);

  const brightness = ((r * 299) + (g * 587) + (b * 114)) / 1000;
  return brightness;
}

function shuffleArray(arr, specific_num) {
  let random_number = specific_num ? specific_num : Math.floor(Math.random() * arr.length) + 1
  return [...arr.slice(arr.length - random_number), ...arr.slice(0, arr.length - random_number)]
}

async function startRoundRoulette(bot, interaction, roulette_games, id, round = 1) {
  let roulette_data = roulette_games.get(interaction.guildID)
  let players = shuffleArray(roulette_data.players.sort((a, b) => a.number - b.number, 0));
  let winner = players[players.length - 1];
  let bufferRouletteImage = await createRouletteGifImage(players)
  await interaction.channel.createMessage(`**${winner.number + 1}** - <@${winner.id}>${players.length <= 2 ? `\n:crown: **هذه الجولة الأخيرة ! اللاعب المختار هو اللاعب الفائز في اللعبة.**` : ""}`, {
    file: bufferRouletteImage,
    name: 'roulette.gif'
  });
  if (players.length <= 2) {
    await interaction.channel.createMessage(`:crown: - فاز <@!${winner.id}> في اللعبة`);
    roulette_games.delete(interaction.guildID);
  } else {
    const game_msg = await interaction.channel.createMessage({
      content: `<@${winner.id}> لديك **30 ثانية** لإختيار لاعب لطرده`, components: getMultipleButtons([
        ...players.slice(0, -1).slice(0, 24).map((player) => ({
          type: 2,
          style: 2,
          label: `${player.number + 1}. ${player.username}`,
          custom_id: `kick_${player.number}_groulette_${interaction.guildID}_${id}`
        })),
        {
          type: 2,
          style: 4,
          label: "انسحاب",
          custom_id: `withdraw_groulette_${interaction.guildID}_${id}`
        }
      ])
    });
    const collecter_buttons = new InteractionCollector(bot, { channel: interaction.channel, time: 30000 })
    collecter_buttons.on('collect', async i => {
      if (i.data && i.data.custom_id && i.type != 2 && i.data.custom_id.endsWith(`groulette_${interaction.guildID}_${id}`)) {
        if (winner.id !== i.member.id) return await i.createMessage({ flags: 64, content: `:x: | فقط الشخص الذي لديه الدور يمكنه الاختيار` })
        await i.deferUpdate();
        collecter_buttons.stop(i.data.custom_id);
      }
    })
    collecter_buttons.on("end", async (interactions, r) => {
      let data = r.split("_")
      if (r.startsWith("kick")) {
        let number = +data[1];
        let player = roulette_data.players.find(player => player.number == number);
        interaction.channel.getMessage(game_msg.id).then(async mm => {
          if (mm.components[0] && !mm.components[0].components[0].disabled) {
            await disabledMultipleButtons(mm)
            await mm.edit({ components: mm.components }).catch(() => { });
            interaction.channel.createMessage(`💣 | تم طرد <@${player.id}> من اللعبة ، سيتم بدء الجولة القادمة في بضع ثواني...`);
            roulette_data.players = roulette_data.players.filter(x => x.number != number);
            roulette_games.set(interaction.guildID, roulette_data);
            await startRoundRoulette(bot, interaction, roulette_games, id, round + 1);
          }
        })
      } else if (r.startsWith("withdraw")) {
        interaction.channel.getMessage(game_msg.id).then(async mm => {
          if (mm.components[0] && !mm.components[0].components[0].disabled) {
            await disabledMultipleButtons(mm)
            await mm.edit({ components: mm.components }).catch(() => { });
            interaction.channel.createMessage(`💣 | لقد انسحب <@${winner.id}> من اللعبة ، سيتم بدء الجولة القادمة في بضع ثواني...`);
            roulette_data.players = roulette_data.players.filter(x => x.id != winner.id);
            roulette_games.set(interaction.guildID, roulette_data);
            await startRoundRoulette(bot, interaction, roulette_games, id, round + 1);
          }
        })
      } else if (r == "time") {
        interaction.channel.getMessage(game_msg.id).then(async mm => {
          if (mm.components[0] && !mm.components[0].components[0].disabled) {
            await disabledMultipleButtons(mm)
            await mm.edit({ components: mm.components }).catch(() => { });
            interaction.channel.createMessage(`💣 | تم طرد <@${winner.id}> من اللعبة لعدم تفاعله ، سيتم بدء الجولة القادمة في بضع ثواني...`);
            roulette_data.players = roulette_data.players.filter(x => x.id != winner.id);
            roulette_games.set(interaction.guildID, roulette_data);
            await startRoundRoulette(bot, interaction, roulette_games, id, round + 1);
          }
        }).catch(console.error);
      }
    })
  }
};


async function runAction(auto_run) {
  console.clear()
  if (await settings.has("reset") && await config.has("token")) {
    if (auto_run) return await startBot(await settings.get("debug") || false, config);
    const { action } = await inquirer.prompt({
      name: "action",
      type: 'list',
      message: `What is the action you want to do?`,
      choices: [
        { name: "Run the bot", value: 0 }, { name: "Run the bot with debug mode", value: 1 }, { name: "Re-setup to put a new token and information", value: 2 }
      ]
    })

    if (action == 0) {
      await settings.set("debug", action);
      return await startBot(false, config);
    } else if (action == 1) {
      await settings.set("debug", action);
      return await startBot(true, config);
    };
  } else {
    console.log(`\nDeveloped By \u001b[32;1mShuruhatik#2443\u001b[0m `)
    await config.delete(`token`);
    const { waiting_time, token_bot, status_type, status_bot } = await inquirer.prompt([
      {
        name: "token_bot",
        mask: "#",
        type: 'password',
        prefix: "\u001b[32;1m1-\u001b[0m",
        message: `Put your Bot token :`,
        mask: "*"
      }, {
        name: "status_bot",
        type: 'input',
        prefix: "\u001b[32;1m2-\u001b[0m",
        message: `Type in the status of the bot you want :`
      }, {
        name: "status_type",
        type: 'rawlist',
        prefix: "\u001b[32;1m3-\u001b[0m",
        message: `Choose the type of bot status :`,
        choices: [
          { name: "Playing", value: 0 }, { name: "Listening", value: 2 }, { name: "Watching", value: 3 }, { name: "Competing", value: 5 }
        ]
      }, {
        name: "waiting_time",
        type: 'number',
        prefix: "\u001b[32;1m4-\u001b[0m",
        default: 40,
        message: `Wait time until the round starts (in seconds) :`
      }
    ]);
    await config.set(`token`, clearTextPrompt(token_bot));
    await settings.set("status_bot", clearTextPrompt(status_bot, true));
    await settings.set("status_type", status_type);
    await settings.set("waiting_time", waiting_time);
    await settings.set("reset", "احذف هذا السطر إذا كنت تريد تحط توكن جديد");
    return await runAction();
  };
};

function sendDM(member, content, file) {
  return new Promise((resolve, reject) => {
    (member.user || member).getDMChannel().then(channel => {
      channel.createMessage(content, file).then(resolve).catch(reject);
    }).catch(reject);
  });
};

function clearTextPrompt(str, status_bot = false) {
  return !status_bot ? str.trim().replaceAll("\\", "").replaceAll(" ", "").replaceAll("~", "") : str.trim().replaceAll("\\", "").replaceAll("~", "")
}

async function startProject() {
  let timeEnd = await settings.has("reset") && await config.has("token") ? 1000 : 5000
  new Interval(async (int) => {
    process.stdout.write('\x1Bc');
    process.stdout.write(`\r\u001b[38;5;${getRandomNumber(230)}m${shuruhatik}\u001b[0m\n\n\u001b[1mﻲﺒﻨﻟﺍ ﻰﻠﻋ ةﻼﺻﻭ رﺎﻔﻐﺘﺳﻻﺍ ﺮﺜﻛﻭ ،ﻪﻠﻟﺍ ﺮﻛﺫ َﺲﻨﺗ ﻻ\u001b[0m`);
    if (int.elapsedTime >= timeEnd) {
      int.pause();
      await runAction(true);
    }
  }, 100).start();
}

export { startProject, shuruhatik, getRandomGifColor, sendDM, createRouletteGifImage, startRoundRoulette, shuffleArray, getRandomNumber, disabledMultipleButtons, createRouletteImage, getRandomDarkHexCode, getMultipleButtons }